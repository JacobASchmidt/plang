module strings

type Builder struct 
    buf [byte]

def (b Builder) Append(p |byte|) Builder 
    return b{.buf = (buf) => reduce(p, buf, (buf, c) => append(buf, c))}

def (b Builder) AppendRunes(p |rune|) Builder
    return b{
        .buf = (buf) => 
            reduce(p, buf, (buf, r) => utf8.AppendRune(buf, r))   
    }

def (b Builder) String() string 
    return string(b.buf)

def Find(s string, sub string) maybe[int]
    def builtTable(sub string, table [int], i int, j int) [int]
        if i >= len(sub)
            return table
        if sub[i] == sub[j] 
            return builtTable(sub, table[i = j+1], i + 1, j + 1)
        else 
            if j == 0
                return builtTable(sub, table[i = 0], i + 1, j)
            else 
                return builtTable(sub, table, i, table[j-1])

    def impl(s string, sub string, table &[int], i int, j int) maybe[int]
        if i == len(s)
            return none()
        if s[i] == sub[j]
            if j + 1 == len(sub)
                return some(i - j)
            else 
                return impl(s, sub, table, i + 1, j + 1)
        else 
            if j == 0
                return impl(s, sub, table, i + 1, j)
            else 
                return impl(s, sub, table, i, table[j - 1])


    table = buildTable(sub, lists.New(len(sub), () => 0), 1, 0)
    return impl(s, sub, table, 0, 0)

def FindAll(s string, sub string) |int|
    def builtTable(sub string, table [int], i int, j int) [int]
        if i == len(sub)
            return table
        if sub[i] == sub[j] 
            return builtTable(sub, table[i = j+1], i + 1, j + 1)
        else 
            if j == 0
                return builtTable(sub, table[i = 0], i + 1, j)
            else 
                return builtTable(sub, table, i, table[j-1])

    def impl(s string, sub string, table &[int], i int, j int) |int|
        if i == len(s)
            return ||
        if s[i] == sub[j]
            if j + 1 == len(sub)
                return |i - j, impl(s, sub, table, i, table[j-1])|
            else 
                return impl(s, sub, table, i + 1, j + 1)
        else 
            if j == 0
                return impl(s, sub, table, i + 1, j)
            else 
                return impl(s, sub, table, i, table[j - 1])

    table = buildTable(sub, lists.New(len(sub), () => 0), 1, 0)
    return impl(s, sub, table, 0, 0)

def Split(s string, delim string) |string|
    # difference between normal find all is that in split we start over after a match
    # e.g. FindAll("ababab", "bab") => |1, 3|
    #  but findAll("ababab", "bab") => |1|
    def findAll(s string, sub string) |int|
        def builtTable(sub string, table [int], i int, j int) [int]
            if i == len(sub)
                return table
            if sub[i] == sub[j] 
                return builtTable(sub, table[i = j+1], i + 1, j + 1)
            else 
                if j == 0
                    return builtTable(sub, table[i = 0], i + 1, j)
                else 
                    return builtTable(sub, table, i, table[j-1])

        def impl(s string, sub string, table &[int], i int, j int) |int|
            if i == len(s)
                return ||
            if s[i] == sub[j]
                if j + 1 == len(sub)
                    # this line is the only difference
                    return |i - j, impl(s, sub, table, i+1, 0)|
                else 
                    return impl(s, sub, table, i + 1, j + 1)
            else 
                if j == 0
                    return impl(s, sub, table, i + 1, j)
                else 
                    return impl(s, sub, table, i, table[j - 1])

        table = buildTable(sub, lists.New(len(sub), () => 0), 1, 0)
        return impl(s, sub, table, 0, 0)
    def getEnd(s string, lenDelim int, idxs |int|) |string|
        match idxs
            case |last|
                return |s[last + lenDelim:]|
            case |first, second, ...rest|
                return |s[first + lenDelim: second], getEnd(s, lenDelim, |second, ...rest|)
            case _
                panic("unreachable")
    
    def getSubstrs(s string, lenDelim int, idxs |int|) |string|
        match idx 
            case |first, ...rest|
                return |s[:first], getEnd(s, lenDelim|first, ...rest|)
            case ||
                return s 
            
    delimIdxs = findAll(s, delim)
    return getSubstrs(s, len(delim), delimIdxs)

def StartsWith(s string, sub string) bool 
    return len(sub) <= len(s) and s[:len(sub)] == sub 

def EndsWith(s string, sub string) bool 
    return len(sub) <= len(s) and s[len(s) - len(sub):] == sub 


def Join(s |string|, sep string) string 
    def doRest(s |string|, sep string, b Builder) string 
        match s 
            case |first, ...rest|
                return doRest(s, sep, b.Append(|sep, first|))
            case ||
                return b.String()
    match s 
        case |first, ...rest|
            return doRest(rest, sep, Builder{}.Append(|first|))
        case ||
            return ""

